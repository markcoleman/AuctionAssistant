/**
 * Tests for AI Vision Service
 */

import {
  AIVisionService,
  createAIVisionService,
  AIVisionConfig,
} from '../src/services/aiVisionService';
import { AnalysisOptions } from '../src/types/productAnalysis';
import path from 'path';
import fs from 'fs/promises';

// Create mock chat completions
const mockCreate = jest.fn();

// Mock OpenAI module
jest.mock('openai', () => {
  return {
    __esModule: true,
    default: jest.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate,
        },
      },
    })),
  };
});

describe('AIVisionService', () => {
  const testDir = path.join(__dirname, '../test-ai-vision');
  const testImagePath = path.join(testDir, 'test-product.jpg');
  let service: AIVisionService;

  beforeAll(async () => {
    // Create test directory
    await fs.mkdir(testDir, { recursive: true });

    // Create a minimal valid JPEG file for testing
    const jpegHeader = Buffer.from([
      0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xff, 0xd9,
    ]);
    await fs.writeFile(testImagePath, jpegHeader);
  });

  afterAll(async () => {
    // Clean up test files
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
    mockCreate.mockReset();

    const config: AIVisionConfig = {
      apiKey: 'test-api-key',
      model: 'gpt-4o',
      maxTokens: 1500,
      temperature: 0.3,
    };

    service = new AIVisionService(config);
  });

  describe('Constructor', () => {
    it('should create service with valid API key', () => {
      expect(service).toBeInstanceOf(AIVisionService);
    });

    it('should throw error when API key is missing', () => {
      expect(() => new AIVisionService({ apiKey: '' })).toThrow(
        'OpenAI API key is required'
      );
    });

    it('should use default configuration values', () => {
      const defaultService = new AIVisionService({ apiKey: 'test-key' });
      expect(defaultService).toBeInstanceOf(AIVisionService);
    });
  });

  describe('analyzeProduct', () => {
    const mockAnalysisResponse = {
      productType: 'Apple iPhone 13 Pro',
      category: {
        primary: 'Electronics',
        secondary: 'Smartphones',
        tertiary: 'iPhone',
        confidence: 'high',
      },
      brand: {
        name: 'Apple',
        confidence: 'high',
        verified: true,
      },
      condition: 'excellent',
      conditionConfidence: 'high',
      attributes: {
        color: ['Graphite'],
        material: ['Glass', 'Aluminum'],
        model: 'iPhone 13 Pro',
        year: '2021',
      },
      extractedText: [
        {
          text: 'iPhone 13 Pro',
          location: 'box',
          confidence: 'high',
        },
      ],
      features: ['128GB storage', '5G capable', 'Triple camera system'],
      defects: null,
      visualQuality: {
        imageQuality: 'excellent',
        lighting: 'good',
        clarity: 'sharp',
        background: 'clean',
        recommendations: [],
      },
      description: 'Apple iPhone 13 Pro in graphite color, excellent condition',
      suggestedTitle: 'Apple iPhone 13 Pro 128GB - Graphite - Excellent',
      suggestedKeywords: ['iPhone', 'Apple', 'smartphone', '5G', '13 Pro'],
      overallConfidence: 'high',
    };

    it('should successfully analyze a product image', async () => {
      // Mock the OpenAI API response
      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: JSON.stringify(mockAnalysisResponse),
            },
          },
        ],
        usage: {
          total_tokens: 850,
        },
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data?.productType).toBe('Apple iPhone 13 Pro');
      expect(result.data?.category.primary).toBe('Electronics');
      expect(result.data?.brand?.name).toBe('Apple');
      expect(result.data?.condition).toBe('excellent');
      expect(result.tokensUsed).toBe(850);
    });

    it('should handle JSON response wrapped in markdown code blocks', async () => {
      const wrappedResponse = `\`\`\`json
${JSON.stringify(mockAnalysisResponse)}
\`\`\``;

      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: wrappedResponse,
            },
          },
        ],
        usage: {
          total_tokens: 850,
        },
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(result.data?.productType).toBe('Apple iPhone 13 Pro');
    });

    it('should handle analysis with custom options', async () => {
      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: JSON.stringify(mockAnalysisResponse),
            },
          },
        ],
        usage: {
          total_tokens: 1200,
        },
      });

      const options: AnalysisOptions = {
        includeOCR: true,
        detailedAnalysis: true,
        generateTitle: true,
        generateKeywords: true,
        maxTokens: 2000,
      };

      const result = await service.analyzeProduct(testImagePath, options);

      expect(result.success).toBe(true);
      expect(mockCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          max_tokens: 2000,
        })
      );
    });

    it('should handle OpenAI API errors', async () => {
      const apiError = {
        status: 429,
        code: 'rate_limit_exceeded',
        type: 'rate_limit_error',
        message: 'Rate limit exceeded',
      };

      mockCreate.mockRejectedValue(apiError);

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      expect(result.error?.code).toBe('rate_limit_exceeded');
      expect(result.error?.retryable).toBe(true);
    });

    it('should handle invalid image file', async () => {
      const result = await service.analyzeProduct('/non/existent/image.jpg');

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      expect(result.error?.message).toContain('Failed to read image file');
    });

    it('should handle empty response from API', async () => {
      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: null,
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain(
        'No response content from OpenAI'
      );
    });

    it('should handle invalid JSON in response', async () => {
      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: 'This is not valid JSON',
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain('Failed to parse AI response');
    });

    it('should set default values for missing fields in response', async () => {
      const minimalResponse = {
        productType: 'Unknown Item',
        category: {
          primary: 'Unknown',
        },
        condition: 'unknown',
      };

      mockCreate.mockResolvedValueOnce({
        choices: [
          {
            message: {
              content: JSON.stringify(minimalResponse),
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(result.data?.productType).toBe('Unknown Item');
      expect(result.data?.features).toEqual([]);
      expect(result.data?.extractedText).toEqual([]);
      expect(result.data?.suggestedKeywords).toEqual([]);
    });
  });

  describe('analyzeMultipleProducts', () => {
    it('should analyze multiple product images', async () => {
      // Ensure clean state
      mockCreate.mockReset();
      
      const mockResponse = {
        productType: 'Test Product',
        category: { primary: 'Test', confidence: 'high' },
        condition: 'good',
        conditionConfidence: 'medium',
        attributes: {},
        extractedText: [],
        features: [],
        visualQuality: {
          imageQuality: 'good',
          lighting: 'good',
          clarity: 'sharp',
          background: 'clean',
        },
        description: 'Test description',
        suggestedTitle: 'Test Title',
        suggestedKeywords: [],
        overallConfidence: 'medium',
      };

      // Use mockResolvedValueOnce for each call to avoid state leakage
      const mockResponseObj = {
        choices: [
          {
            message: {
              content: JSON.stringify(mockResponse),
            },
          },
        ],
        usage: { total_tokens: 500 },
      };
      
      mockCreate
        .mockResolvedValueOnce(mockResponseObj)
        .mockResolvedValueOnce(mockResponseObj);

      const imagePaths = [testImagePath, testImagePath];
      const results = await service.analyzeMultipleProducts(imagePaths);

      expect(results).toHaveLength(2);
      expect(results[0].success).toBe(true);
      expect(results[1].success).toBe(true);
    });

    it('should handle mixed success and failure results', async () => {
      // Ensure completely clean mock state at test start
      mockCreate.mockReset();
      
      // First call succeeds, second fails
      mockCreate
        .mockResolvedValueOnce({
          choices: [
            {
              message: {
                content: JSON.stringify({
                  productType: 'Product 1',
                  category: { primary: 'Test', confidence: 'high' },
                  condition: 'good',
                  conditionConfidence: 'medium',
                  attributes: {},
                  extractedText: [],
                  features: [],
                  visualQuality: {
                    imageQuality: 'good',
                    lighting: 'good',
                    clarity: 'sharp',
                    background: 'clean',
                  },
                  description: 'Test',
                  suggestedTitle: 'Test',
                  suggestedKeywords: [],
                  overallConfidence: 'medium',
                }),
              },
            },
          ],
        })
        .mockRejectedValueOnce(new Error('API Error'));

      const imagePaths = [testImagePath, testImagePath];
      const results = await service.analyzeMultipleProducts(imagePaths);

      expect(results).toHaveLength(2);
      expect(results[0].success).toBe(true);
      expect(results[1].success).toBe(false);
    });
  });

  describe('createAIVisionService', () => {
    const originalEnv = process.env;

    beforeEach(() => {
      jest.resetModules();
      process.env = { ...originalEnv };
    });

    afterEach(() => {
      process.env = originalEnv;
    });

    it('should create service from environment variable', () => {
      process.env.OPENAI_API_KEY = 'env-test-key';
      const service = createAIVisionService();
      expect(service).toBeInstanceOf(AIVisionService);
    });

    it('should create service with provided API key', () => {
      const service = createAIVisionService('provided-test-key');
      expect(service).toBeInstanceOf(AIVisionService);
    });

    it('should throw error when API key is not available', () => {
      delete process.env.OPENAI_API_KEY;
      expect(() => createAIVisionService()).toThrow(
        'OpenAI API key not provided'
      );
    });

    it('should use environment configuration', () => {
      process.env.OPENAI_API_KEY = 'test-key';
      process.env.OPENAI_VISION_MODEL = 'gpt-4-vision-preview';
      process.env.OPENAI_MAX_TOKENS = '2000';
      process.env.OPENAI_TEMPERATURE = '0.5';

      const service = createAIVisionService();
      expect(service).toBeInstanceOf(AIVisionService);
    });
  });

  describe('Image encoding', () => {
    it('should encode JPEG images correctly', async () => {
      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: JSON.stringify({
                productType: 'Test',
                category: { primary: 'Test', confidence: 'high' },
                condition: 'good',
                conditionConfidence: 'medium',
                attributes: {},
                extractedText: [],
                features: [],
                visualQuality: {
                  imageQuality: 'good',
                  lighting: 'good',
                  clarity: 'sharp',
                  background: 'clean',
                },
                description: 'Test',
                suggestedTitle: 'Test',
                suggestedKeywords: [],
                overallConfidence: 'medium',
              }),
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(mockCreate).toHaveBeenCalled();

      const call = mockCreate.mock.calls[0][0];
      const imageContent = call.messages[0].content.find(
        (c: { type: string }) => c.type === 'image_url'
      );

      expect(imageContent.image_url.url).toMatch(/^data:image\/jpeg;base64,/);
    });
  });

  describe('Error handling', () => {
    it('should handle rate limit errors as retryable', async () => {
      const rateLimitError = {
        status: 429,
        code: 'rate_limit_exceeded',
        type: 'rate_limit_error',
        message: 'Rate limit exceeded',
      };

      mockCreate.mockRejectedValue(rateLimitError);

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.retryable).toBe(true);
    });

    it('should handle server errors as retryable', async () => {
      const serverError = {
        status: 500,
        code: 'internal_error',
        type: 'server_error',
        message: 'Internal server error',
      };

      mockCreate.mockRejectedValue(serverError);

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.retryable).toBe(true);
    });

    it('should handle client errors as non-retryable', async () => {
      const clientError = {
        status: 400,
        code: 'bad_request',
        type: 'client_error',
        message: 'Bad request',
      };

      mockCreate.mockRejectedValue(clientError);

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.retryable).toBe(false);
    });

    it('should handle unknown errors gracefully', async () => {
      mockCreate.mockRejectedValue('Something went wrong');

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(false);
      expect(result.error?.code).toBe('UNKNOWN_ERROR');
      expect(result.error?.retryable).toBe(false);
    });
  });

  describe('Response parsing', () => {
    it('should parse complete analysis response correctly', async () => {
      const completeResponse = {
        productType: 'Vintage Camera',
        category: {
          primary: 'Electronics',
          secondary: 'Photography',
          tertiary: 'Film Cameras',
          confidence: 'high',
        },
        brand: {
          name: 'Canon',
          confidence: 'high',
          verified: true,
        },
        condition: 'good',
        conditionConfidence: 'high',
        attributes: {
          color: ['Black'],
          material: ['Metal', 'Plastic'],
          model: 'AE-1',
          year: '1976',
        },
        extractedText: [
          { text: 'Canon AE-1', location: 'body', confidence: 'high' },
        ],
        features: ['Manual focus', 'Film camera', '35mm'],
        defects: {
          scratches: true,
          wear: true,
          description: 'Minor scratches on body',
          severity: 'minor',
        },
        visualQuality: {
          imageQuality: 'good',
          lighting: 'good',
          clarity: 'sharp',
          background: 'clean',
        },
        description: 'Vintage Canon AE-1 film camera in good condition',
        suggestedTitle: 'Canon AE-1 Vintage Film Camera - Good Condition',
        suggestedKeywords: ['Canon', 'AE-1', 'film camera', 'vintage', '35mm'],
        overallConfidence: 'high',
      };

      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: JSON.stringify(completeResponse),
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(result.data?.productType).toBe('Vintage Camera');
      expect(result.data?.brand?.name).toBe('Canon');
      expect(result.data?.defects?.scratches).toBe(true);
      expect(result.data?.defects?.severity).toBe('minor');
      expect(result.data?.extractedText).toHaveLength(1);
      expect(result.data?.features).toContain('Manual focus');
    });

    it('should handle response with null brand', async () => {
      const response = {
        productType: 'Generic Item',
        category: { primary: 'Misc', confidence: 'low' },
        brand: null,
        condition: 'unknown',
        conditionConfidence: 'low',
        attributes: {},
        extractedText: [],
        features: [],
        visualQuality: {
          imageQuality: 'fair',
          lighting: 'fair',
          clarity: 'slightly_blurry',
          background: 'clean',
        },
        description: 'Generic item',
        suggestedTitle: 'Item',
        suggestedKeywords: [],
        overallConfidence: 'low',
      };

      mockCreate.mockResolvedValue({
        choices: [
          {
            message: {
              content: JSON.stringify(response),
            },
          },
        ],
      });

      const result = await service.analyzeProduct(testImagePath);

      expect(result.success).toBe(true);
      expect(result.data?.brand).toBeUndefined();
    });
  });
});
